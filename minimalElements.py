'''
find efficient way to take upset in and get minimal elements out
'''
'''
example:
powerset 2^X
            [a, b, c, d]
[a, b, c] [a, b, d] [a, c, d] [b, c, d]
[a, b] [a, c] [a, d] [b, c] [b, d] [c, d]
[a]        [b]          [c]         [d]
                  []
-if we have an upset generated by [(a), (c)], then all of the things in 2^X that contain a or c will be in the upset.
so given the upset [(a), (a, b), (a, b, c), (a, b, c, d), (a, c), (a, b, d)], how can we quickly find out minimal els
-so if we just look at [a, b, c, d] and take the upset above, and want to generate the upset for [(a), (c)], we can just
take the union of ([(a)] U 2^(b, c, d)) and ([(c)] and 2^(a, b, c))

facts to use:
if a whole level of powerset is in the upset

best implementation findMinElems7

'''

#from sortedcontainers import SortedSet

def findMinElems(upset):
    minElems = []

    for s in upset:
        is_minimal = True

        for sPrime in upset:
            if sPrime != s and set(sPrime).issubset(set(s)):
                is_minimal = False
                break

        if is_minimal:
            minElems.append(s)

    return minElems

# little stuff optimized, sorted and uses sets which are faster.
def findMinElems2(upset):
    # Convert each element to a set once
    converted_upset = [set(s) for s in upset]
    # Sort by the size of the sets to optimize subset checking
    converted_upset.sort(key=len)
    minElems = []

    for i, s in enumerate(converted_upset):
        is_minimal = True
        # Only compare with elements of equal or smaller size
        for j in range(i):
            if converted_upset[j].issubset(s):
                is_minimal = False
                break
        if is_minimal:
            # Convert back to the original type if necessary
            minElems.append(list(s))

    return minElems

# uses rules about size
def findMinElems3(upset):

    #had to use weird looping because deleting elements messes it up

    minElems = []
    # smallest size elem of the upset
    minSize = len(upset[0])

    # add all elements of minimum size O(4n)
    for i in range(len(upset)):
        if upset[i] == minSize:
            minElems.append(upset[i])
            del upset[i]
            i -= 1


    #convert all to set at once O(n)
    for i in upset:
        i = set(i)

    #looping through to find more min elements, removing as we go
    while len(upset) > 0: #O((n-j)*j)
        checkMin = upset[0]
        if not any(j.issubset(checkMin) for j in minElems):
            minElems.append(checkMin)
            del upset[0]
            continue
        del upset[0]

    return minElems


def findMinElems4(upset):
    # sort by length
    sorted_upset = sorted(upset, key=len) #O(nlogn)
    minElems = []
    minSize = len(sorted_upset[0])

    while len(sorted_upset[0]) == minSize: #O(k < n) k number of elems w/ minsize
        minElems.append(sorted_upset[0])
        del sorted_upset[0]

    for i in sorted_upset:
        i = set(i)

    #maybe something to do here because they are sorted
    while len(sorted_upset) > 0: #O((n-j)*j)
        checkMin = sorted_upset[0]
        if not any(j.issubset(checkMin) for j in minElems):
            minElems.append(checkMin)
            del sorted_upset[0]
            continue
        del sorted_upset[0]

    return minElems

def findMinElems5(upset):
    # frozensets faster operations
    sortedUpset = sorted(map(frozenset, upset), key=len)
    minElems = []


    minSize = len(sortedUpset[0])

    # all sets of minimal size are minimal elements
    index = 0
    while index < len(sortedUpset) and len(sortedUpset[index]) == minSize:
        minElems.append(sortedUpset[index])
        index += 1

    # check remaining elements against minElems
    for s in sortedUpset[index:]:
        # Check if there is no set in minimal_elements that is a subset of s
        if not any(minimal.issubset(s) for minimal in minElems):
            minElems.append(s)

    return minElems

def findMinElems6(upset):
    sortedUpset = sorted(map(frozenset, upset), key=len)
    minElems = []
    uniqueElements = set()

    minSize = len(sortedUpset[0])
    index = 0
    while index < len(sortedUpset) and len(sortedUpset[index]) == minSize:
        minElems.append(sortedUpset[index])
        uniqueElements.update(sortedUpset[index])
        index += 1

    for s in sortedUpset[index:]:
        # Check if 's' contains any element not in 'uniqueElements'
        if not s <= uniqueElements:
            # If 's' has unique elements, further check for minimality
            if not any(minimal.issubset(s) for minimal in minElems):
                minElems.append(s)
                uniqueElements.update(s)

    return minElems

def findMinElems7(upset): # O(𝑛(𝑘+log𝑛)𝑚) where n is elems in upset and k is num minimal elements
    sortedUpset = sorted(map(frozenset, upset), key=len)

    minElems = []

    while sortedUpset:
        currentSet = sortedUpset.pop(0)
        # current set is minimal. minimum size all minimal, and then all their supersets are removed
        minElems.append(currentSet)

        # if current set is a subset of anything in upperset, remove it
        sortedUpset = [s for s in sortedUpset if not currentSet.issubset(s)]

    return minElems












